namespace CUP
{
	using System;
	using Symbol = CUP.runtime.Symbol;
	
	/// <summary>This class implements a small scanner (aka lexical analyzer or lexer) for
	/// the JavaCup specification.  This scanner reads characters from standard 
	/// input (System.in) and returns integers corresponding to the terminal 
	/// number of the next Symbol. Once end of input is reached the EOF Symbol is 
	/// returned on every subsequent call.<p>
	/// Symbols currently returned include: <pre>
	/// Symbol        Constant Returned     Symbol        Constant Returned
	/// ------        -----------------     ------        -----------------
	/// "package"     PACKAGE               "import"      IMPORT 
	/// "code"        CODE                  "action"      ACTION 
	/// "parser"      PARSER                "terminal"    TERMINAL
	/// "non"         NON                   "init"        INIT 
	/// "scan"        SCAN                  "with"        WITH
	/// "start"       START                 "precedence"  PRECEDENCE
	/// "left"        LEFT		  "right"       RIGHT
	/// "nonassoc"    NONASSOC		  "%prec        PRECENT_PREC  
	/// [           LBRACK                  ]           RBRACK
	/// ;           SEMI 
	/// ,           COMMA                   *           STAR 
	/// .           DOT                     :           COLON
	/// ::=         COLON_COLON_EQUALS      |           BAR
	/// identifier    ID                    {:...:}       CODE_STRING
	/// "nonterminal" NONTERMINAL
	/// </pre>
	/// All symbol constants are defined in sym.java which is generated by 
	/// JavaCup from parser.cup.<p>
	/// 
	/// In addition to the scanner proper (called first via init() then with
	/// next_token() to get each Symbol) this class provides simple error and 
	/// warning routines and keeps a count of errors and warnings that is 
	/// publicly accessible.<p>
	/// 
	/// This class is "static" (i.e., it has only static members and methods).
	/// *
	/// </summary>
	/// <version> last updated: 7/3/96
	/// </version>
	/// <author>  Frank Flannery
	/// 
	/// </author>
	public class lexer
	{
		private static System.IO.Stream _inStream = null;

		/*-----------------------------------------------------------*/
		/*--- Constructor(s) ----------------------------------------*/
		/*-----------------------------------------------------------*/
		
		/// <summary>The only constructor is private, so no instances can be created. 
		/// </summary>
		public lexer()
		{
		}
		
		/*-----------------------------------------------------------*/
		/*--- Static (Class) Variables ------------------------------*/
		/*-----------------------------------------------------------*/
		
		/// <summary>First character of lookahead. 
		/// </summary>
		protected internal static int next_char;
		
		/// <summary>Second character of lookahead. 
		/// </summary>
		protected internal static int next_char2;
		
		/// <summary>Second character of lookahead. 
		/// </summary>
		protected internal static int next_char3;
		
		/// <summary>Second character of lookahead. 
		/// </summary>
		protected internal static int next_char4;
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>EOF constant. 
		/// </summary>
		protected internal static int EOF_CHAR = - 1;
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>Table of keywords.  Keywords are initially treated as identifiers.
		/// Just before they are returned we look them up in this table to see if
		/// they match one of the keywords.  The string of the name is the key here,
		/// which indexes Integer objects holding the symbol number. 
		/// </summary>
		protected internal static System.Collections.Hashtable keywords = new System.Collections.Hashtable(23);
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>Table of single character symbols.  For ease of implementation, we 
		/// store all unambiguous single character Symbols in this table of Integer
		/// objects keyed by Integer objects with the numerical value of the 
		/// appropriate char (currently Character objects have a bug which precludes
		/// their use in tables).
		/// </summary>
		protected internal static System.Collections.Hashtable char_symbols = new System.Collections.Hashtable(11);
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>Current line number for use in error messages. 
		/// </summary>
		protected internal static int current_line = 1;
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>Character position in current line. 
		/// </summary>
		protected internal static int current_position = 1;
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>Character position in current line. 
		/// </summary>
		protected internal static int absolute_position = 1;
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>Count of total errors detected so far. 
		/// </summary>
		public static int error_count = 0;
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>Count of warnings issued so far 
		/// </summary>
		public static int warning_count = 0;
		
		public static void SetStream(System.IO.Stream inStream)
		{
			_inStream = inStream;
		}

		/*-----------------------------------------------------------*/
		/*--- Static Methods ----------------------------------------*/
		/*-----------------------------------------------------------*/
		
		/// <summary>Initialize the scanner.  This sets up the keywords and char_symbols
		/// tables and reads the first two characters of lookahead.  
		/// </summary>
		public static void  init()
		{
			/* set up the keyword table */
			SupportClass.PutElement(keywords, "package", sym.PACKAGE);
			SupportClass.PutElement(keywords, "import", sym.IMPORT);
			SupportClass.PutElement(keywords, "code", sym.CODE);
			SupportClass.PutElement(keywords, "action", sym.ACTION);
			SupportClass.PutElement(keywords, "parser", sym.PARSER);
			SupportClass.PutElement(keywords, "terminal", sym.TERMINAL);
			SupportClass.PutElement(keywords, "non", sym.NON);
			SupportClass.PutElement(keywords, "nonterminal", sym.NONTERMINAL); // [CSA]
			SupportClass.PutElement(keywords, "init", sym.INIT);
			SupportClass.PutElement(keywords, "scan", sym.SCAN);
			SupportClass.PutElement(keywords, "with", sym.WITH);
			SupportClass.PutElement(keywords, "start", sym.START);
			SupportClass.PutElement(keywords, "precedence", sym.PRECEDENCE);
			SupportClass.PutElement(keywords, "left", sym.LEFT);
			SupportClass.PutElement(keywords, "right", sym.RIGHT);
			SupportClass.PutElement(keywords, "nonassoc", sym.NONASSOC);
			
			/* set up the table of single character symbols */
			SupportClass.PutElement(char_symbols, ';', sym.SEMI);
			SupportClass.PutElement(char_symbols, ',', sym.COMMA);
			SupportClass.PutElement(char_symbols, '*', sym.STAR);
			SupportClass.PutElement(char_symbols, '.', sym.DOT);
			SupportClass.PutElement(char_symbols, '|', sym.BAR);
			SupportClass.PutElement(char_symbols, '[', sym.LBRACK);
			SupportClass.PutElement(char_symbols, ']', sym.RBRACK);
			
			/* read two characters of lookahead */
			next_char = _inStream.ReadByte();
			if (next_char == EOF_CHAR)
			{
				next_char2 = EOF_CHAR;
				next_char3 = EOF_CHAR;
				next_char4 = EOF_CHAR;
			}
			else
			{
				next_char2 = _inStream.ReadByte();
				if (next_char2 == EOF_CHAR)
				{
					next_char3 = EOF_CHAR;
					next_char4 = EOF_CHAR;
				}
				else
				{
					next_char3 = _inStream.ReadByte();
					if (next_char3 == EOF_CHAR)
					{
						next_char4 = EOF_CHAR;
					}
					else
					{
						next_char4 = _inStream.ReadByte();
					}
				}
			}
		}
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>Advance the scanner one character in the input stream.  This moves
		/// next_char2 to next_char and then reads a new next_char2.  
		/// </summary>
		protected internal static void  advance()
		{
			int old_char;
			
			old_char = next_char;
			next_char = next_char2;
			if (next_char == EOF_CHAR)
			{
				next_char2 = EOF_CHAR;
				next_char3 = EOF_CHAR;
				next_char4 = EOF_CHAR;
			}
			else
			{
				next_char2 = next_char3;
				if (next_char2 == EOF_CHAR)
				{
					next_char3 = EOF_CHAR;
					next_char4 = EOF_CHAR;
				}
				else
				{
					next_char3 = next_char4;
					if (next_char3 == EOF_CHAR)
					{
						next_char4 = EOF_CHAR;
					}
					else
					{
						next_char4 = _inStream.ReadByte();
					}
				}
			}
			
			/* count this */
			absolute_position++;
			current_position++;
			if (old_char == '\n' || (old_char == '\r' && next_char != '\n'))
			{
				current_line++;
				current_position = 1;
			}
		}
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>Emit an error message.  The message will be marked with both the 
		/// current line number and the position in the line.  Error messages
		/// are printed on standard error (System.err).
		/// </summary>
		/// <param name="message">the message to print.
		/// 
		/// </param>
		public static void  emit_error(string message)
		{
			System.Console.Error.WriteLine("Error at " + current_line + "(" + current_position + "): " + message);
			error_count++;
		}
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>Emit a warning message.  The message will be marked with both the 
		/// current line number and the position in the line.  Messages are 
		/// printed on standard error (System.err).
		/// </summary>
		/// <param name="message">the message to print.
		/// 
		/// </param>
		public static void  emit_warn(string message)
		{
			System.Console.Error.WriteLine("Warning at " + current_line + "(" + current_position + "): " + message);
			warning_count++;
		}
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>Determine if a character is ok to start an id. 
		/// </summary>
		/// <param name="ch">the character in question.
		/// 
		/// </param>
		protected internal static bool id_start_char(int ch)
		{
			/* allow for % in identifiers.  a hack to allow my
			%prec in.  Should eventually make lex spec for this 
			frankf */
			return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch == '_');
			
			// later need to deal with non-8-bit chars here
		}
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>Determine if a character is ok for the middle of an id.
		/// </summary>
		/// <param name="ch">the character in question. 
		/// 
		/// </param>
		protected internal static bool id_char(int ch)
		{
			return id_start_char(ch) || (ch >= '0' && ch <= '9');
		}
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>Try to look up a single character symbol, returns -1 for not found. 
		/// </summary>
		/// <param name="ch">the character in question.
		/// </param>
		protected internal static int find_single_char(int ch)
		{
			if(char_symbols.ContainsKey((char)ch)) 
			{
				return((int)char_symbols[(char)ch]);
			}
			else 
			{
				return(-1);
			}
		}
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>Handle swallowing up a comment.  Both old style C and new style C++
		/// comments are handled.
		/// </summary>
		protected internal static void  swallow_comment()
		{
			/* next_char == '/' at this point */
			
			/* is it a traditional comment */
			if (next_char2 == '*')
			{
				/* swallow the opener */
				advance(); advance();
				
				/* swallow the comment until end of comment or EOF */
				 for (; ; )
				{
					/* if its EOF we have an error */
					if (next_char == EOF_CHAR)
					{
						emit_error("Specification file ends inside a comment");
						return ;
					}
					
					/* if we can see the closer we are done */
					if (next_char == '*' && next_char2 == '/')
					{
						advance();
						advance();
						return ;
					}
					
					/* otherwise swallow char and move on */
					advance();
				}
			}
			
			/* is its a new style comment */
			if (next_char2 == '/')
			{
				/* swallow the opener */
				advance(); advance();
				
				/* swallow to '\n', '\r', '\f', or EOF */
				while (next_char != '\n' && next_char != '\r' && next_char != '\f' && next_char != EOF_CHAR)
				{
					advance();
				}
				
				return ;
				
			}
			
			/* shouldn't get here, but... if we get here we have an error */
			emit_error("Malformed comment in specification -- ignored");
			advance();
		}
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>Swallow up a code string.  Code strings begin with "{:" and include
		/// all characters up to the first occurrence of ":}" (there is no way to 
		/// include ":}" inside a code string).  The routine returns a String
		/// object suitable for return by the scanner.
		/// </summary>
		protected internal static Symbol do_code_string()
		{
			System.Text.StringBuilder result = new System.Text.StringBuilder();
			
			/* at this point we have lookahead of "{:" -- swallow that */
			advance(); advance();
			
			/* save chars until we see ":}" */
			while (!(next_char == ':' && next_char2 == '}'))
			{
				/* if we have run off the end issue a message and break out of loop */
				if (next_char == EOF_CHAR)
				{
					emit_error("Specification file ends inside a code string");
					break;
				}
				
				/* otherwise record the char and move on */
				result.Append((char) next_char);
				advance();
			}
			
			/* advance past the closer and build a return Symbol */
			advance(); advance();
			return new Symbol(sym.CODE_STRING, result.ToString());
		}
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>Process an identifier.  Identifiers begin with a letter, underscore,
		/// or dollar sign, which is followed by zero or more letters, numbers,
		/// underscores or dollar signs.  This routine returns a String suitable
		/// for return by the scanner.
		/// </summary>
		protected internal static Symbol do_id()
		{
			System.Text.StringBuilder result = new System.Text.StringBuilder();
			System.String result_str;
			System.Int32 keyword_num;
			char[] buffer = new char[1];
			
			/* next_char holds first character of id */
			buffer[0] = (char) next_char;
			result.Append(buffer, 0, 1);
			advance();
			
			/* collect up characters while they fit in id */
			while (id_char(next_char))
			{
				buffer[0] = (char) next_char;
				result.Append(buffer, 0, 1);
				advance();
			}
			
			/* extract a string and try to look it up as a keyword */
			result_str = result.ToString();
			if(!keywords.ContainsKey(result_str)) 
			{
				return(new Symbol(sym.ID, result_str));
			}
			keyword_num = (System.Int32) keywords[result_str];
			return new Symbol(keyword_num);
		}
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>Return one Symbol.  This is the main external interface to the scanner.
		/// It consumes sufficient characters to determine the next input Symbol
		/// and returns it.  To help with debugging, this routine actually calls
		/// real_next_token() which does the work.  If you need to debug the 
		/// parser, this can be changed to call debug_next_token() which prints
		/// a debugging message before returning the Symbol.
		/// </summary>
		public static Symbol next_token()
		{
			return real_next_token();
		}
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>Debugging version of next_token().  This routine calls the real scanning
		/// routine, prints a message on System.out indicating what the Symbol is,
		/// then returns it.
		/// </summary>
		public static Symbol debug_next_token()
		{
			Symbol result = real_next_token();
			System.Console.Out.WriteLine("# next_Symbol() => " + result.sym);
			return result;
		}
		
		/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
		
		/// <summary>The actual routine to return one Symbol.  This is normally called from
		/// next_token(), but for debugging purposes can be called indirectly from
		/// debug_next_token(). 
		/// </summary>
		protected internal static Symbol real_next_token()
		{
			int sym_num;
			
			 for (; ; )
			{
				/* look for white space */
				if (next_char == ' ' || next_char == '\t' || next_char == '\n' || next_char == '\f' || next_char == '\r')
				{
					/* advance past it and try the next character */
					advance();
					continue;
				}
				
				/* look for a single character symbol */
				sym_num = find_single_char(next_char);
				if (sym_num != - 1)
				{
					/* found one -- advance past it and return a Symbol for it */
					advance();
					return new Symbol(sym_num);
				}
				
				/* look for : or ::= */
				if (next_char == ':')
				{
					/* if we don't have a second ':' return COLON */
					if (next_char2 != ':')
					{
						advance();
						return new Symbol(sym.COLON);
					}
					
					/* move forward and look for the '=' */
					advance();
					if (next_char2 == '=')
					{
						advance(); advance();
						return new Symbol(sym.COLON_COLON_EQUALS);
					}
					else
					{
						/* return just the colon (already consumed) */
						return new Symbol(sym.COLON);
					}
				}
				
				/* find a "%prec" string and return it.  otherwise, a '%' was found,
				which has no right being in the specification otherwise */
				if (next_char == '%')
				{
					advance();
					if ((next_char == 'p') && (next_char2 == 'r') && (next_char3 == 'e') && (next_char4 == 'c'))
					{
						advance();
						advance();
						advance();
						advance();
						return new Symbol(sym.PERCENT_PREC);
					}
					else
					{
						emit_error("Found extraneous percent sign");
					}
				}
				
				/* look for a comment */
				if (next_char == '/' && (next_char2 == '*' || next_char2 == '/'))
				{
					/* swallow then continue the scan */
					swallow_comment();
					continue;
				}
				
				/* look for start of code string */
				if (next_char == '{' && next_char2 == ':')
					return do_code_string();
				
				/* look for an id or keyword */
				if (id_start_char(next_char))
					return do_id();
				
				/* look for EOF */
				if (next_char == EOF_CHAR)
					return new Symbol(sym.EOF);
				
				/* if we get here, we have an unrecognized character */
				emit_warn("Unrecognized character '" + (char) next_char + "'(" + next_char + ") -- ignored");
				
				/* advance past it */
				advance();
			}
		}
		
		/*-----------------------------------------------------------*/
	}
}